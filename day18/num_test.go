package day18

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestParse(t *testing.T) {
	tests := []struct {
		input string
		want  *Node
	}{
		{"[1,2]", N(1, 2)},
		{"[[1,2],3]", N(N(1, 2), 3)},
		{"[9,[8,7]]", N(9, N(8, 7))},
		// more from the examples
		// [[1,9],[8,5]]
		// [[[[1,2],[3,4]],[[5,6],[7,8]]],9]
		// [[[9,[3,8]],[[0,9],6]],[[[3,7],[4,9]],3]]
		// [[[[1,3],[5,3]],[[1,3],[8,7]]],[[[4,9],[6,9]],[[8,2],[7,3]]]]
	}
	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			got, err := Parse(tt.input)
			assert.NoError(t, err)
			assert.Equal(t, tt.want, got)
		})
	}
}

func (n *Node) valid(t *testing.T, parent *Node) {
	if t != nil {
		require.Equal(t, parent, n.parent)
	} else if parent != n.parent {
		panic(nil)
	}
	n.left.valid(t, n, parent)
	n.right.valid(t, n, parent)
}

func (i *item) valid(t *testing.T, container, parent *Node) {
	if i.n != nil {
		if t != nil {
			require.Zero(t, i.val)
		} else if i.val != 0 {
			panic(nil)
		}
		i.n.valid(t, container)
	}
}

func TestAdd(t *testing.T) {
	tests := []struct {
		l, r string
		want string
	}{
		{
			"[1,2]", "[3,4]",
			"[[1,2],[3,4]]",
		},
		{
			"[[[[4,3],4],4],[7,[[8,4],9]]]",
			"[1,1]",
			"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]",
		},
		{
			"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]",
			"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]",
			"[[[[4,0],[5,4]],[[7,7],[6,0]]],[[8,[7,7]],[[7,9],[5,0]]]]",
		},
		{
			"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]",
			"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]",
			"[[[[4,0],[5,4]],[[7,7],[6,0]]],[[8,[7,7]],[[7,9],[5,0]]]]",
		},
		{
			"[[[[4,0],[5,4]],[[7,7],[6,0]]],[[8,[7,7]],[[7,9],[5,0]]]]",
			"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]",
			"[[[[6,7],[6,7]],[[7,7],[0,7]]],[[[8,7],[7,7]],[[8,8],[8,0]]]]",
		},
		{
			"[[[[6,7],[6,7]],[[7,7],[0,7]]],[[[8,7],[7,7]],[[8,8],[8,0]]]]",
			"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]",
			"[[[[7,0],[7,7]],[[7,7],[7,8]]],[[[7,7],[8,8]],[[7,7],[8,7]]]]",
		},
		{
			"[[[[7,0],[7,7]],[[7,7],[7,8]]],[[[7,7],[8,8]],[[7,7],[8,7]]]]",
			"[7,[5,[[3,8],[1,4]]]]",
			"[[[[7,7],[7,8]],[[9,5],[8,7]]],[[[6,8],[0,8]],[[9,9],[9,0]]]]",
		},
		{
			"[[[[7,7],[7,8]],[[9,5],[8,7]]],[[[6,8],[0,8]],[[9,9],[9,0]]]]",
			"[[2,[2,2]],[8,[8,1]]]",
			"[[[[6,6],[6,6]],[[6,0],[6,7]]],[[[7,7],[8,9]],[8,[8,1]]]]",
		},
		{
			"[[[[6,6],[6,6]],[[6,0],[6,7]]],[[[7,7],[8,9]],[8,[8,1]]]]",
			"[2,9]",
			"[[[[6,6],[7,7]],[[0,7],[7,7]]],[[[5,5],[5,6]],9]]",
		},
		{
			"[[[[6,6],[7,7]],[[0,7],[7,7]]],[[[5,5],[5,6]],9]]",
			"[1,[[[9,3],9],[[9,0],[0,7]]]]",
			"[[[[7,8],[6,7]],[[6,8],[0,8]]],[[[7,7],[5,0]],[[5,5],[5,6]]]]",
		},
		{
			"[[[[7,8],[6,7]],[[6,8],[0,8]]],[[[7,7],[5,0]],[[5,5],[5,6]]]]",
			"[[[5,[7,4]],7],1]",
			"[[[[7,7],[7,7]],[[8,7],[8,7]]],[[[7,0],[7,7]],9]]",
		},
		{
			"[[[[7,7],[7,7]],[[8,7],[8,7]]],[[[7,0],[7,7]],9]]",
			"[[[[4,2],2],6],[8,7]]",
			"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]",
		},
	}
	for _, tt := range tests {
		t.Run(tt.l+"+"+tt.r, func(t *testing.T) {
			l, err := Parse(tt.l)
			require.NoError(t, err)
			l.valid(t, nil)
			r, err := Parse(tt.r)
			require.NoError(t, err)
			r.valid(t, nil)
			s := add(l, r)
			s.valid(t, nil)
			sum := Add(l, r)
			assert.Equal(t, tt.want, sum.String())
		})
	}
}

func TestNode_explodeWalk(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"[[[[[9,8],1],2],3],4]", "[[[[0,9],2],3],4]"},
		{"[7,[6,[5,[4,[3,2]]]]]", "[7,[6,[5,[7,0]]]]"},
		{"[[6,[5,[4,[3,2]]]],1]", "[[6,[5,[7,0]]],3]"},
		{"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]", "[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]"},
		{"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]", "[[3,[2,[8,0]]],[9,[5,[7,0]]]]"},

		{"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]", "[[[[0,7],4],[7,[[8,4],9]]],[1,1]]"},
		{"[[[[0,7],4],[7,[[8,4],9]]],[1,1]]", "[[[[0,7],4],[15,[0,13]]],[1,1]]"},
		{"[[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]", "[[[[0,7],4],[[7,8],[6,0]]],[8,1]]"},
	}
	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			n, err := Parse(tt.input)
			require.NoError(t, err)
			exploded := n.explodeWalk(0)
			n.valid(t, nil)
			assert.Equal(t, tt.input != tt.want, exploded)
			assert.Equal(t, tt.want, n.String())
		})
	}
}

func TestNode_Magnitude(t *testing.T) {
	tests := []struct {
		input string
		want  int
	}{
		{"[9,1]", 29},
		{"[1,9]", 21},
		{"[[9,1],[1,9]]", 129},
		{"[[1,2],[[3,4],5]]", 143},
		{"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]", 1384},
		{"[[[[1,1],[2,2]],[3,3]],[4,4]]", 445},
		{"[[[[3,0],[5,3]],[4,4]],[5,5]]", 791},
		{"[[[[5,0],[7,4]],[5,5]],[6,6]]", 1137},
		{"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]", 3488},
	}
	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			n, err := Parse(tt.input)
			require.NoError(t, err)
			assert.Equal(t, tt.want, n.Magnitude())
		})
	}
}
